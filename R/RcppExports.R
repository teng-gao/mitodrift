# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

prop_clades_par <- function(E_target, edges, rooted = TRUE, normalize = TRUE) {
    .Call('_mitodrift_prop_clades_par', PACKAGE = 'mitodrift', E_target, edges, rooted, normalize)
}

#' Leaf likelihood matrix via C++ backend
#'
#' @param amat Integer matrix of alt counts (variants x cells).
#' @param dmat Integer matrix of depths (same dimensions as `amat`).
#' @param vafs Numeric vector of VAF grid points (names optional).
#' @param eps Error rate to add to each VAF bin (default 0).
#' @param ncores Number of threads to use (default 1).
#' @param log Whether to return log-likelihoods instead of probabilities.
#' @return List of matrices, one per variant, with rows = VAF bins and columns = cells.
#' @export
get_leaf_liks_mat_cpp <- function(amat, dmat, vafs, eps = 0.0, ncores = 1L, log = FALSE) {
    .Call('_mitodrift_get_leaf_liks_mat_cpp', PACKAGE = 'mitodrift', amat, dmat, vafs, eps, ncores, log)
}

#' definitions for logSumExp function
NULL

reorderRcpp <- function(E) {
    .Call('_mitodrift_reorderRcpp', PACKAGE = 'mitodrift', E)
}

nnin_cpp <- function(E, n) {
    .Call('_mitodrift_nnin_cpp', PACKAGE = 'mitodrift', E, n)
}

#' logSumExp function for a vector
#'
#' @param x NumericVector
#' @return double logSumExp of x
#' @export
logSumExp <- function(x) {
    .Call('_mitodrift_logSumExp', PACKAGE = 'mitodrift', x)
}

score_tree_bp <- function(E, logP, logA, n, C, m, root) {
    .Call('_mitodrift_score_tree_bp', PACKAGE = 'mitodrift', E, logP, logA, n, C, m, root)
}

score_tree_bp_wrapper <- function(E, logP_list, logA) {
    .Call('_mitodrift_score_tree_bp_wrapper', PACKAGE = 'mitodrift', E, logP_list, logA)
}

score_tree_bp2 <- function(E, logP, logA, n, C, m, root) {
    .Call('_mitodrift_score_tree_bp2', PACKAGE = 'mitodrift', E, logP, logA, n, C, m, root)
}

score_tree_bp_wrapper2 <- function(E, logP_list, logA) {
    .Call('_mitodrift_score_tree_bp_wrapper2', PACKAGE = 'mitodrift', E, logP_list, logA)
}

compute_node_edge_beliefs_bp2 <- function(E, logP_list, logA) {
    .Call('_mitodrift_compute_node_edge_beliefs_bp2', PACKAGE = 'mitodrift', E, logP_list, logA)
}

score_trees_parallel <- function(trees, logP, logA) {
    .Call('_mitodrift_score_trees_parallel', PACKAGE = 'mitodrift', trees, logP, logA)
}

score_tree_bp_wrapper_multi <- function(E, logP_list, logA_list) {
    .Call('_mitodrift_score_tree_bp_wrapper_multi', PACKAGE = 'mitodrift', E, logP_list, logA_list)
}

nni_cpp_parallel <- function(E, logP, logA) {
    .Call('_mitodrift_nni_cpp_parallel', PACKAGE = 'mitodrift', E, logP, logA)
}

nni_cpp_parallel_cached <- function(E, logP, logA) {
    .Call('_mitodrift_nni_cpp_parallel_cached', PACKAGE = 'mitodrift', E, logP, logA)
}

nni_cpp_parallel_multi <- function(E, logP, logA) {
    .Call('_mitodrift_nni_cpp_parallel_multi', PACKAGE = 'mitodrift', E, logP, logA)
}

tree_mcmc_cpp <- function(E, logP, logA, max_iter = 100L, seed = -1L) {
    .Call('_mitodrift_tree_mcmc_cpp', PACKAGE = 'mitodrift', E, logP, logA, max_iter, seed)
}

tree_mcmc_cpp_cached <- function(E, logP, logA, max_iter = 100L, seed = -1L) {
    .Call('_mitodrift_tree_mcmc_cpp_cached', PACKAGE = 'mitodrift', E, logP, logA, max_iter, seed)
}

tree_mcmc_cpp_cached_threadsafe <- function(E, logP, logA, max_iter = 100L, seed = -1L, reorder = TRUE) {
    .Call('_mitodrift_tree_mcmc_cpp_cached_threadsafe', PACKAGE = 'mitodrift', E, logP, logA, max_iter, seed, reorder)
}

tree_mcmc_parallel <- function(E, logP, logA, max_iter, nchains) {
    .Call('_mitodrift_tree_mcmc_parallel', PACKAGE = 'mitodrift', E, logP, logA, max_iter, nchains)
}

tree_mcmc_parallel_seeded <- function(start_edges, logP, logA, max_iter_vec, seeds) {
    .Call('_mitodrift_tree_mcmc_parallel_seeded', PACKAGE = 'mitodrift', start_edges, logP, logA, max_iter_vec, seeds)
}

tree_mcmc_parallel_seeded_locus <- function(start_edges, logP, logA, max_iter_vec, seeds) {
    .Call('_mitodrift_tree_mcmc_parallel_seeded_locus', PACKAGE = 'mitodrift', start_edges, logP, logA, max_iter_vec, seeds)
}

compute_node_edge_stats_bp2 <- function(E, logP_list, logA) {
    .Call('_mitodrift_compute_node_edge_stats_bp2', PACKAGE = 'mitodrift', E, logP_list, logA)
}

#' Parallel qdata saver
#' 
#' @param objects List of data-only R objects to serialize (unsupported types become NULL, mirroring `qd_save`).
#' @param paths Character vector of output file paths (must match length of `objects`).
#' @param compress_level Compression level passed to qdata (default 3).
#' @param shuffle Whether to enable byte shuffling (default TRUE).
#' @param grain_size Chunk size for parallel processing (default 1).
#' @return NULL invisibly on success; character vector of error messages otherwise.
#' @export
save_qd_cpp <- function(objects, paths, compress_level = 3L, shuffle = TRUE, grain_size = 1L) {
    .Call('_mitodrift_save_qd_cpp', PACKAGE = 'mitodrift', objects, paths, compress_level, shuffle, grain_size)
}

